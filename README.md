# MULTITHREADED-FILE-COMPRESSION-TOOL
*COMPANY*: CODTECH IT SOLUTIONS
*NAME*: ADI BAIS
*INTERN ID*: CT04DL600
*DOMAIN*: C++ PROGRAMMING
*DURATION*: 4 WEEKS
*MENTOR*: NEELA SANTOSH

DESCRIPTION:
This C++ program is a comprehensive, interactive file-handling tool that showcases advanced file operations including multithreaded compression and decompression using Run-Length Encoding (RLE). It uses a combination of standard C++ libraries such as <iostream>, <fstream>, <vector>, <string>, <thread>, and <mutex> to efficiently manage files and perform parallel processing. The program begins with a user-driven menu interface allowing the selection of three key actions: creating a file, compressing a file, or decompressing a file. When a user chooses to create a file, the program prompts for a filename and accepts multiple lines of input from the user, writing them line-by-line into a file using std::ofstream. For compression, the tool reads the entire content of a file into a std::vector<char> using binary mode via std::ifstream, then splits this data into chunks based on the number of available hardware threads, determined using std::thread::hardware_concurrency(). Each chunk is passed to a separate thread which performs RLE compression using a custom function compressRLEChunk(), which encodes repeating characters into a pair of the character and its count (up to 255). The results from all threads are collected and merged. The program compares the size of the compressed data against the original, and depending on efficiency, it stores either the compressed data prefixed with a 'C' or the uncompressed original prefixed with a 'U' in a binary output file using std::ofstream in binary mode. This ensures storage optimization without sacrificing data fidelity. On the decompression side, the program reads the header to determine if the file is compressed or not. If compressed, it again divides the data into equal pairs (character and count), assigns segments to different threads, and uses decompressRLEChunk() to reconstruct the original content. It ensures that each chunk is valid (i.e., has an even number of bytes) and handles errors accordingly. All threads are synchronized using std::thread and the join() method to ensure the main thread waits for each decompression task to finish. Decompressed chunks are then merged and written to a new output file. The use of std::mutex ensures thread-safe console output during parallel execution, preventing race conditions when displaying messages. The program also includes proper error handling for invalid files, unreadable input, or incorrect compression formats. This implementation not only demonstrates classic file I/O operations like reading, writing, and appending, but it also integrates binary file handling and multithreading, making it a powerful tool for demonstrating real-world C++ capabilities in file management and data processing. Furthermore, the RLE technique used, although simple, is efficient for compressing files with repeated characters, such as logs or simple text files. This program is ideal for educational demonstrations of concurrent programming, file compression algorithms, and structured system-level I/O in C++, while also serving as a practical utility for lightweight file compression and decompression tasks
